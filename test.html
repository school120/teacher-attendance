<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, viewport-fit=cover" />
<title>Guard Booth Attendance Kiosk</title>
<meta name="description" content="Guard kiosk for IN/OUT with card swipe/tap or name lookup" />
<meta name="color-scheme" content="light dark">
<meta id="meta-theme" name="theme-color" content="#ffffff">
<style>
  :root{
    --bg:#f6f7fb;
    --card:#ffffff;
    --text:#0f172a;
    --muted:#667085;
    --border:#e5e7eb;
    --in:#16a34a;
    --out:#dc2626;
    --blue:#2563eb;
    --ok:#0f766e;
    --err:#b91c1c;
    --radius-lg:14px;
    --radius-xl:18px;
    --shadow-1:0 10px 30px rgba(0,0,0,.08);
    --ring:0 0 0 6px rgba(59,130,246,.16);
  }
  body.dark{
    --bg:#0b1020;
    --card:#111827;
    --text:#f9fafb;
    --muted:#cbd5e1;
    --border:#374151;
  }

  *{ box-sizing:border-box; -webkit-tap-highlight-color:transparent; }
  html, body { height:100%; margin:0; background:var(--bg); color:var(--text); font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif; }
  html { overflow-x:hidden; }
  body{
    min-height:100svh;
    overscroll-behavior-y:contain;
    overflow:auto;
    -webkit-overflow-scrolling:touch;
    padding-top: env(safe-area-inset-top, 0px);
  }

  .wrap{
    margin:auto;
    width:min(1100px,96%);
    background:var(--card);
    border-radius:var(--radius-xl);
    box-shadow:var(--shadow-1);
    position:relative;
    min-height:calc(100svh - env(safe-area-inset-top, 0px));
    padding:28px;
    padding-top:calc(28px + env(safe-area-inset-top, 0px));
    overflow:visible;
    overflow-x:clip;
  }

  .top-row{
    position: relative;
    margin-bottom: 16px;
    padding-top: 36px;
  }

  .top-center{
    text-align:center;
    max-width:100%;
  }

  .left-badges,
  .right-badges{
    position:absolute;
    top:0;
    display:flex;
    gap:8px;
    align-items:center;
    flex-wrap:wrap;
  }

  .left-badges{ left:0; }
  .right-badges{ right:0; }

  h1{ margin:0 0 6px; font-weight:900; font-size:30px; letter-spacing:.2px; }
  .muted{ color:var(--muted); }

  .badge{
    font-size:12px;
    font-weight:800;
    padding:6px 10px;
    border-radius:999px;
    border:1px solid var(--border);
    background:var(--card);
    color:var(--text);
    white-space:nowrap;
    font-family:inherit;
  }

  .badge.net.online{
    background:#dcfce7;
    border-color:#86efac;
    color:#166534;
  }
  .badge.net.offline{
    background:#fee2e2;
    border-color:#fca5a5;
    color:#991b1b;
  }

  .badge.syncing{
    background:#fef3c7;
    border-color:#fcd34d;
    color:#92400e;
  }

  #themeBtn{
    font-size:12px;
    font-weight:800;
    padding:6px 12px;
    border-radius:999px;
    border:1px solid var(--border);
    background:var(--card);
    color:var(--text);
    display:flex;
    align-items:center;
    gap:6px;
    cursor:pointer;
    font-family:inherit;
  }
  #themeBtn span{
    font-size:12px;
    letter-spacing:.08em;
  }
  #themeBtn:hover,
  #themeBtn:focus-visible{
    border-color:#3b82f6;
    box-shadow:var(--ring);
    outline:none;
  }

  @media (max-width:700px){
    .top-row{
      padding-top:64px;
    }
    .top-center{
      padding:0 12px;
    }
  }

  .toast{
    position:fixed;
    left:50%;
    bottom:24px;
    transform:translateX(-50%) translateY(20px);
    opacity:0;
    background:var(--card);
    border:1px solid var(--border);
    box-shadow:0 8px 30px rgba(0,0,0,.12);
    border-radius:14px;
    padding:18px 22px;
    font-weight:900;
    font-size:20px;
    transition:all .18s ease;
    pointer-events:none;
    z-index:50;
    text-align:center;
  }
  .toast.show{ opacity:1; transform:translateX(-50%) translateY(0); }
  .toast.ok{ color:var(--ok); }
  .toast.err{ color:var(--err); }

  .segment{
    display:flex;
    gap:14px;
    width:100%;
    margin:16px 0 20px;
  }
  .segment.segment-xl button{
    flex:1 1 0;
    border:2px solid #d1d5db;
    border-radius:16px;
    font-weight:900;
    font-size:42px;
    line-height:1.1;
    min-height:96px;
    padding:22px 24px;
    cursor:pointer;
    color:#111827;
    background:linear-gradient(180deg, #f8fafc 0%, #e5e7eb 100%);
    transition:transform .06s ease, box-shadow .2s ease, background .2s ease, border-color .2s ease, color .2s ease;
    box-shadow:0 4px 10px rgba(0,0,0,.08);
  }
  .segment.segment-xl button.active#actIn{
    background:linear-gradient(180deg, #16a34a 0%, #15803d 100%);
    color:#fff;
    border-color:#16a34a;
    box-shadow:0 0 0 4px rgba(22,163,74,.25);
  }
  .segment.segment-xl button.active#actOut{
    background:linear-gradient(180deg, #dc2626 0%, #991b1b 100%);
    color:#fff;
    border-color:#dc2626;
    box-shadow:0 0 0 4px rgba(220,38,38,.25);
  }

  .grid{
    display:grid;
    grid-template-columns:1fr 1fr;
    gap:18px;
    align-items:stretch;
  }
  .card{
    border:1px solid var(--border);
    border-radius:14px;
    background:var(--card);
    padding:16px;
    display:flex;
    flex-direction:column;
    height:100%;
    overflow:hidden;
    background-clip: padding-box;
  }
  .card h2{
    margin:0 0 12px;
    font-size:20px;
    text-align:center;
  }

  input[type=password],
  input[type=search]{
    width:100%;
    padding:18px 20px;
    font-size:24px;
    border:1.5px solid var(--border);
    border-radius:12px;
    background:var(--card);
    color:var(--text);
  }
  input[type=password]::placeholder,
  input[type=search]::placeholder{
    color:var(--muted);
  }
  input[type=password]:focus-visible,
  input[type=search]:focus-visible{
    border-color:#3b82f6;
    box-shadow:var(--ring);
    outline:none;
  }

  .list{
    display:grid;
    gap:12px;
    max-height:460px;
    overflow:auto;
    margin-top:14px;
    background:var(--card);
    background-clip: padding-box;
    -webkit-overflow-scrolling: touch;
    overscroll-behavior: contain;
    flex:1 1 auto;
    padding-right:16px;
    scrollbar-gutter: stable both-edges;
  }
  .row{
    display:grid;
    grid-template-columns:minmax(0,1fr) auto;
    align-items:center;
    gap:12px;
    padding:14px 16px;
    border:1px solid var(--border);
    border-radius:12px;
    background: var(--card);
  }
  .name{
    min-width:0;
    font-weight:800;
    font-size:20px;
    color:var(--text);
    overflow:hidden;
    text-overflow:ellipsis;
    white-space:nowrap;
  }
  .actionBtn{
    --c: var(--blue);
    background:linear-gradient(180deg, var(--c) 0%, color-mix(in srgb, var(--c) 80%, #000 20%) 100%);
    color:#fff;
    font-size:20px;
    padding:16px 20px;
    border:2px solid var(--c);
    border-radius:14px;
    font-weight:900;
    cursor:pointer;
    box-shadow:0 6px 14px rgba(0,0,0,.15);
    justify-self:end;
  }

  .sectionHdr{
    text-align:center;
    font-weight:900;
    font-size:14px;
    letter-spacing:.12em;
    color:var(--muted);
    padding:10px 0 2px;
  }

  @media (max-width:900px){
    .grid{ grid-template-columns:1fr; }
    .segment.segment-xl button{ font-size:36px; min-height:88px; }
  }

  .boot-overlay{
    position:fixed;
    inset:0;
    background:rgba(15,23,42,.78);
    display:flex;
    align-items:center;
    justify-content:center;
    z-index:60;
  }
  .boot-overlay-inner{
    background:var(--card);
    color:var(--text);
    padding:20px 26px;
    border-radius:16px;
    box-shadow:0 18px 40px rgba(0,0,0,.35);
    display:flex;
    flex-direction:column;
    align-items:center;
    gap:10px;
    min-width:260px;
    text-align:center;
  }
  .boot-spinner{
    width:32px;
    height:32px;
    border-radius:999px;
    border:3px solid rgba(148,163,184,.7);
    border-top-color:var(--blue);
    animation:spin 0.7s linear infinite;
  }
  .boot-text{
    font-weight:800;
    font-size:16px;
  }
  @keyframes spin{
    to{ transform:rotate(360deg); }
  }
</style>
</head>
<body>
  <div class="wrap" role="application" aria-label="Guard Booth Attendance Kiosk">

    <div class="top-row">
      <div class="left-badges">
        <div id="rosterStatus" class="badge">Roster: ‚è≥ loading‚Ä¶</div>
        <div id="queueStatus" class="badge">Queue ‚úÖ0</div>
      </div>

      <div class="top-center">
        <h1>Guard Booth Attendance Kiosk</h1>
        <p class="muted">Select <b>IN</b> or <b>OUT</b>, then swipe/tap Cougar Card or search by name.</p>
      </div>

      <div class="right-badges">
        <button id="themeBtn" title="Toggle theme" aria-label="Toggle dark mode">
          üåô <span>Dark</span>
        </button>
        <div id="netBadge" class="badge net online">Online</div>
      </div>
    </div>

    <div class="segment segment-xl" role="tablist" aria-label="Action">
      <button id="actIn" class="active" role="tab" aria-selected="true" type="button">IN</button>
      <button id="actOut" role="tab" aria-selected="false" type="button">OUT</button>
    </div>

    <div class="grid">
      <div class="card">
        <h2>Cougar Card</h2>
        <input id="pin" type="password" maxlength="32" inputmode="numeric" autocomplete="one-time-code" placeholder="Tap or swipe card‚Ä¶" />
      </div>

      <div class="card">
        <h2>Lookup by Name</h2>
        <input id="q" type="search" inputmode="search" enterkeyhint="search" autocapitalize="words" autocorrect="off" spellcheck="false" placeholder="Search faculty or students" />
        <div id="results" class="list" role="list" aria-live="polite"></div>
      </div>
    </div>

    <div id="toast" class="toast" role="status" aria-live="polite"></div>

    <div id="bootOverlay" class="boot-overlay" aria-live="polite" aria-busy="true">
      <div class="boot-overlay-inner">
        <div class="boot-spinner" aria-hidden="true"></div>
        <div class="boot-text">Loading rosters‚Ä¶</div>
      </div>
    </div>
  </div>

<script>
(() => {
  'use strict';

  const ENDPOINT = 'https://script.google.com/macros/s/AKfycbzF4Hy0W2ZBbB6dOPRcT3PIKsEZekW2HtHuPAAp99jwUpasH7Iq1mMYCtQ35WEPfkiQQw/exec';
  const VC_BASE  = 'https://checkin.veracross.com/frisch/kiosk/entrance?legacy=';
  
  // Config
  const COOLDOWN_MS = 250;
  const DEDUPE_WINDOW_MS = 5000;
  const WEDGE_QUIET_MS = 100;
  const BATCH_SIZE = 10;
  const BATCH_DELAY_MS = 2000;
  const MAX_RETRY_ATTEMPTS = 5;
  const RETRY_BACKOFF_BASE = 1000;
  const ROSTER_CACHE_TTL = 3600000; // 1 hour

  const $ = s => document.querySelector(s);
  const digitsOnly = s => String(s||'').replace(/\D+/g,'');
  const clamp = (n,min,max) => Math.min(max,Math.max(min,n));

  // Elements
  const pinEl = $('#pin'), qEl = $('#q'), toastEl = $('#toast');
  const btnIn = $('#actIn'), btnOut = $('#actOut');
  const netBadge = $('#netBadge'), themeBtn = $('#themeBtn');
  const rosterStatusEl = $('#rosterStatus');
  const queueStatusEl = $('#queueStatus');
  const bootOverlay = $('#bootOverlay');

  /* ================= State Management ================= */
  const State = {
    action: 'in',
    roster: {
      students: new Map(),
      faculty: new Map(),
      studentList: [],
      facultyList: [],
      timestamp: null,
      checksum: null
    },
    queue: {
      pending: [],
      errors: [],
      syncing: false
    },
    lastSync: {
      success: null,
      failure: null
    },
    lastSubmit: 0,
    lastSeen: new Map(),

    load() {
      try {
        const saved = localStorage.getItem('kiosk_state');
        if (saved) {
          const data = JSON.parse(saved);
          if (data.action) this.action = data.action;
          if (data.lastSync) this.lastSync = data.lastSync;
          if (data.roster && data.roster.timestamp) {
            // Check if roster cache is still valid
            const age = Date.now() - data.roster.timestamp;
            if (age < ROSTER_CACHE_TTL) {
              this.roster.students = new Map(data.roster.students || []);
              this.roster.faculty = new Map(data.roster.faculty || []);
              this.roster.studentList = data.roster.studentList || [];
              this.roster.facultyList = data.roster.facultyList || [];
              this.roster.timestamp = data.roster.timestamp;
              this.roster.checksum = data.roster.checksum;
            }
          }
        }
        
        // Load queues
        this.queue.pending = JSON.parse(localStorage.getItem('pending_scans') || '[]');
        this.queue.errors = JSON.parse(localStorage.getItem('client_error_queue') || '[]');
      } catch(e) {
        console.error('Failed to load state:', e);
      }
    },

    save() {
      try {
        const toSave = {
          action: this.action,
          lastSync: this.lastSync,
          roster: {
            students: Array.from(this.roster.students.entries()),
            faculty: Array.from(this.roster.faculty.entries()),
            studentList: this.roster.studentList,
            facultyList: this.roster.facultyList,
            timestamp: this.roster.timestamp,
            checksum: this.roster.checksum
          }
        };
        localStorage.setItem('kiosk_state', JSON.stringify(toSave));
        localStorage.setItem('pending_scans', JSON.stringify(this.queue.pending));
        localStorage.setItem('client_error_queue', JSON.stringify(this.queue.errors));
      } catch(e) {
        console.error('Failed to save state:', e);
      }
    },

    setAction(val) {
      this.action = val;
      this.save();
    },

    updateRoster(data) {
      this.roster.students.clear();
      this.roster.faculty.clear();
      
      Object.entries(data.studentByLegacy || {}).forEach(([k, v]) => {
        this.roster.students.set(k, v);
      });
      
      Object.entries(data.facultyPins || {}).forEach(([k, v]) => {
        this.roster.faculty.set(k, v);
      });
      
      this.roster.studentList = data.studentList || [];
      this.roster.facultyList = data.facultyList || [];
      this.roster.timestamp = Date.now();
      this.roster.checksum = data.checksum;
      
      this.lastSync.success = {
        serverTs: data.ts || Date.now(),
        clientTs: Date.now()
      };
      
      this.save();
    },

    recordSyncFailure(message) {
      this.lastSync.failure = {
        clientTs: Date.now(),
        message: String(message || 'failed')
      };
      this.save();
    },

    queueScan(payload) {
      payload.id = `${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
      payload.attempts = 0;
      payload.priority = Date.now();
      this.queue.pending.push(payload);
      this.save();
    },

    queueError(payload) {
      payload.id = `${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
      payload.attempts = 0;
      this.queue.errors.push(payload);
      this.save();
    },

    removeScan(id) {
      this.queue.pending = this.queue.pending.filter(s => s.id !== id);
      this.save();
    },

    removeError(id) {
      this.queue.errors = this.queue.errors.filter(e => e.id !== id);
      this.save();
    },

    canSendNow(key) {
      const now = Date.now();
      const last = this.lastSeen.get(key) || 0;
      if (now - last < DEDUPE_WINDOW_MS) return false;
      this.lastSeen.set(key, now);
      return true;
    },

    makeKey({ pin, personId }) {
      return pin ? `pin:${pin}` : `pid:${personId}`;
    }
  };

  /* ================= Toast ================= */
  const Toast = (() => {
    let timer = null;
    function show(text, ok=true, dur=2200){
      toastEl.textContent = text;
      toastEl.classList.toggle('ok', ok);
      toastEl.classList.toggle('err', !ok);
      toastEl.classList.add('show');
      clearTimeout(timer);
      timer = setTimeout(()=>toastEl.classList.remove('show'), clamp(dur,600,4000));
    }
    return { show };
  })();

  /* ================= Chimes ================= */
  const Chime = (() => {
    let audioCtx=null, master=null, comp=null, dist=null, ready=false;
    function init(){
      if (ready) return;
      const AC = window.AudioContext || window.webkitAudioContext;
      audioCtx = new AC();
      comp = audioCtx.createDynamicsCompressor();
      comp.threshold.setValueAtTime(-12, audioCtx.currentTime);
      comp.knee.setValueAtTime(24, audioCtx.currentTime);
      comp.ratio.setValueAtTime(16, audioCtx.currentTime);
      comp.attack.setValueAtTime(0.002, audioCtx.currentTime);
      comp.release.setValueAtTime(0.08, audioCtx.currentTime);
      dist = audioCtx.createWaveShaper();
      dist.curve = (function(amount=60){
        const n=44100,c=new Float32Array(n),deg=Math.PI/180;
        for(let i=0;i<n;i++){
          const x=(i*2)/n-1;
          c[i]=(3+amount)*x*20*deg/(Math.PI+amount*Math.abs(x));
        }
        return c;
      })();
      dist.oversample='4x';
      master = audioCtx.createGain();
      master.gain.setValueAtTime(0.95, audioCtx.currentTime);
      master.connect(comp).connect(audioCtx.destination);
      const kick = ()=> audioCtx.resume?.().catch(()=>{});
      window.addEventListener('pointerdown', kick, { once:true, passive:true });
      window.addEventListener('keydown', kick, { once:true });
      ready = true;
    }
    function tone({ f=880, dur=0.18, t=audioCtx.currentTime, type='sine', g=0.7, distOn=false, detune=0 }){
      const o=audioCtx.createOscillator(), gn=audioCtx.createGain();
      o.type=type; o.frequency.setValueAtTime(f,t);
      if (detune) o.detune.setValueAtTime(detune,t);
      gn.gain.setValueAtTime(0,t);
      gn.gain.linearRampToValueAtTime(g,t+0.012);
      gn.gain.exponentialRampToValueAtTime(0.0001,t+dur);
      (distOn ? o.connect(gn).connect(dist).connect(master) : o.connect(gn).connect(master));
      o.start(t); o.stop(t+dur+0.02);
    }
    function ok(){
      init();
      const t0=audioCtx.currentTime+0.01;
      tone({f:659.25, dur:0.14, t:t0, g:1.0});
      tone({f:830.61, dur:0.14, t:t0+0.12, g:1.0});
      tone({f:987.77, dur:0.16, t:t0+0.24, g:1.0});
      tone({f:1318.5, dur:0.22, t:t0+0.36, g:1.0});
    }
    function fail(){
      init();
      const t0=audioCtx.currentTime+0.01;
      tone({f:440.00, dur:0.16, t:t0, type:'square', g:1.0, distOn:true});
      tone({f:369.99, dur:0.16, t:t0+0.12, type:'square', g:0.95, distOn:true});
      tone({f:293.66, dur:0.20, t:t0+0.24, type:'square', g:0.9, distOn:true});
    }
    return { ok, fail };
  })();

  /* ================= Theme ================= */
  function setTheme(mode){
    const dark = mode === 'dark';
    document.body.classList.toggle('dark', dark);
    themeBtn.innerHTML = dark ? '‚òÄÔ∏è <span>Light</span>' : 'üåô <span>Dark</span>';
    const metaTheme = document.getElementById('meta-theme');
    if (metaTheme) metaTheme.content = dark ? '#0b1020' : '#ffffff';
    localStorage.setItem('theme', dark ? 'dark' : 'light');
  }
  function initTheme(){
    const saved = localStorage.getItem('theme');
    if (saved) { setTheme(saved); return; }
    const prefersDark = window.matchMedia?.('(prefers-color-scheme: dark)').matches;
    setTheme(prefersDark ? 'dark' : 'light');
  }
  themeBtn.addEventListener('click', () => {
    setTheme(document.body.classList.contains('dark') ? 'light' : 'dark');
    themeBtn.blur();
    setTimeout(focusPinSafely, 0);
  });

  /* ================= Network badge ================= */
  function updateNet(){
    const on = navigator.onLine;
    if (!netBadge) return;
    netBadge.textContent = on ? 'Online' : 'Offline';
    netBadge.classList.add('net');
    netBadge.classList.toggle('online', on);
    netBadge.classList.toggle('offline', !on);
  }
  window.addEventListener('online', () => {
    updateNet();
    setTimeout(processQueues, 500);
  }, { passive:true });
  window.addEventListener('offline', updateNet, { passive:true });

  /* ================= Focus helpers ================= */
  function focusPin(){ try { pinEl.focus(); pinEl.select?.(); } catch(_) {} }
  function focusPinSafely(){ if (document.activeElement !== qEl) focusPin(); }
  document.addEventListener('visibilitychange', () => { if (!document.hidden) focusPinSafely(); });
  window.addEventListener('pageshow', (e) => { if (e.persisted) focusPinSafely(); });

  /* ================= Action toggle ================= */
  function setAction(a){
    const inActive = a === 'in';
    btnIn.classList.toggle('active', inActive);
    btnOut.classList.toggle('active', !inActive);
    btnIn.setAttribute('aria-selected', inActive);
    btnOut.setAttribute('aria-selected', !inActive);
    State.setAction(a);
    setTimeout(focusPinSafely, 0);
  }

  btnIn.addEventListener('click', () => setAction('in'));
  btnOut.addEventListener('click', () => setAction('out'));
  window.addEventListener('keydown', (e)=>{
    if(e.key==='ArrowLeft') setAction('in');
    if(e.key==='ArrowRight') setAction('out');
  });

  function applyHashAction(){
    const h = (location.hash || '').toLowerCase();
    if (h === '#out') setAction('out');
    else if (h === '#in') setAction('in');
  }
  window.addEventListener('hashchange', applyHashAction);

  /* ================= UI Updates ================= */
  function fmtShortTs(ts){
    if (!ts) return '';
    const d = new Date(ts);
    return d.toLocaleString('en-US', {
      month:'short', day:'numeric', hour:'numeric', minute:'2-digit'
    });
  }

  function updateRosterStatusLabel(){
    if (!rosterStatusEl) return;

    let label = 'Roster: ‚è≥ loading‚Ä¶';
    let title = '';

    const success = State.lastSync.success;
    const failure = State.lastSync.failure;

    if (success){
      const when = fmtShortTs(success.serverTs || success.clientTs);
      const hasRoster = State.roster.students.size > 0 || State.roster.faculty.size > 0;
      
      label = hasRoster ? `‚ö° Roster OK ¬∑ ${when}` : `‚ö†Ô∏è Roster fallback ¬∑ ${when}`;
      title += `Last success: ${fmtShortTs(success.clientTs || success.serverTs)}`;
    } else {
      if (failure){
        label = `‚ùå Roster failed`;
        title += `Last failure: ${fmtShortTs(failure.clientTs)} (${failure.message||'failed'})`;
      } else {
        label = `Roster: ‚è≥ loading‚Ä¶`;
        title = `No successful roster downloads yet`;
      }
    }

    if (failure && success){
      const whenF = fmtShortTs(failure.clientTs);
      title += `\nLast failure: ${whenF} (${failure.message||'failed'})`;
    }

    rosterStatusEl.textContent = label;
    rosterStatusEl.title = title || 'Roster bootstrap status';
  }

  function updateQueueStatusLabel(){
    if (!queueStatusEl) return;
    
    const pending = State.queue.pending.length;
    const errors = State.queue.errors.length;

    let label = 'Queue ‚úÖ0';
    let title = 'No pending scans or errors.';

    if (State.queue.syncing) {
      label = `Queue ‚è≥ syncing...`;
      title = 'Syncing pending scans to server...';
      queueStatusEl.classList.add('syncing');
    } else {
      queueStatusEl.classList.remove('syncing');
      if (pending > 0 || errors > 0) {
        label = `Queue üïí${pending} ‚ö†Ô∏è${errors}`;
        title = 'Pending scans and errors are stored locally and will retry automatically when online.';
      }
    }

    queueStatusEl.textContent = label;
    queueStatusEl.title = title;
  }

  /* ================= Bootstrap Roster ================= */
  async function loadBootstrap(){
    try {
      const res = await fetch(ENDPOINT + '?action=bootstrap', {
        signal: AbortSignal.timeout(10000)
      });
      
      if (!res.ok) {
        throw new Error('Bootstrap HTTP ' + res.status);
      }
      
      const data = await res.json();
      State.updateRoster(data);
      updateRosterStatusLabel();
      return true;
    } catch(e) {
      State.recordSyncFailure(e.message || 'bootstrap failed');
      updateRosterStatusLabel();
      throw e;
    }
  }

  /* ================= Queue Processing with Batching ================= */
  let batchTimer = null;

  async function processQueues() {
    if (!navigator.onLine || State.queue.syncing) return;
    
    const hasPending = State.queue.pending.length > 0;
    const hasErrors = State.queue.errors.length > 0;
    
    if (!hasPending && !hasErrors) {
      updateQueueStatusLabel();
      return;
    }

    State.queue.syncing = true;
    updateQueueStatusLabel();

    // Process errors first (they're logged, not actual scans)
    await processBatchErrors();
    
    // Then process pending scans
    await processBatchScans();

    State.queue.syncing = false;
    updateQueueStatusLabel();
  }

  async function processBatchErrors() {
    if (State.queue.errors.length === 0) return;

    const batch = State.queue.errors.slice(0, BATCH_SIZE);
    const toRemove = [];

    for (const item of batch) {
      try {
        const body = new URLSearchParams({
          action: 'client_error',
          note: item.note || 'client_error',
          ...item
        }).toString();

        const res = await fetch(ENDPOINT, {
          method: 'POST',
          headers: {'Content-Type': 'application/x-www-form-urlencoded'},
          body,
          signal: AbortSignal.timeout(5000)
        });

        if (res.ok) {
          toRemove.push(item.id);
        } else if (item.attempts >= MAX_RETRY_ATTEMPTS) {
          toRemove.push(item.id);
        } else {
          item.attempts = (item.attempts || 0) + 1;
        }
      } catch(e) {
        if (item.attempts >= MAX_RETRY_ATTEMPTS) {
          toRemove.push(item.id);
        } else {
          item.attempts = (item.attempts || 0) + 1;
        }
      }
    }

    toRemove.forEach(id => State.removeError(id));
  }

  async function processBatchScans() {
    if (State.queue.pending.length === 0) return;

    // Sort by priority (timestamp)
    State.queue.pending.sort((a, b) => a.priority - b.priority);

    const batch = State.queue.pending.slice(0, BATCH_SIZE);
    
    // Try to send as a batch first
    if (batch.length > 1) {
      try {
        const res = await fetch(ENDPOINT, {
          method: 'POST',
          headers: {'Content-Type': 'application/x-www-form-urlencoded'},
          body: new URLSearchParams({
            action: 'batch',
            scans: JSON.stringify(batch.map(s => ({
              action: s.action,
              src: s.src,
              pin: s.pin || '',
              personId: s.personId || '',
              firstName: s.firstName || '',
              lastName: s.lastName || '',
              grade: s.grade || '',
              clientTs: s.clientTs
            })))
          }).toString(),
          signal: AbortSignal.timeout(10000)
        });

        if (res.ok) {
          const data = await res.json();
          if (data.results && Array.isArray(data.results)) {
            // Remove successful ones
            data.results.forEach((result, i) => {
              if (result.success !== false) {
                State.removeScan(batch[i].id);
              }
            });
            return;
          }
        }
      } catch(e) {
        // Batch failed, fall through to individual processing
      }
    }

    // Process individually with retry logic
    const toRemove = [];
    for (const item of batch) {
      const shouldRetry = await processSingleScan(item);
      if (!shouldRetry) {
        toRemove.push(item.id);
      }
    }

    toRemove.forEach(id => State.removeScan(id));
  }

  async function processSingleScan(item) {
    const backoff = Math.min(
      RETRY_BACKOFF_BASE * Math.pow(2, item.attempts || 0),
      30000
    );

    if (item.attempts > 0) {
      await new Promise(resolve => setTimeout(resolve, backoff));
    }

    try {
      const body = new URLSearchParams({
        action: item.action,
        src: item.src || '',
        pin: item.pin || '',
        personId: item.personId || '',
        firstName: item.firstName || '',
        lastName: item.lastName || '',
        grade: item.grade || '',
        clientTs: item.clientTs || String(Date.now())
      }).toString();

      const res = await fetch(ENDPOINT, {
        method: 'POST',
        headers: {'Content-Type': 'application/x-www-form-urlencoded'},
        body,
        signal: AbortSignal.timeout(8000)
      });

      if (res.ok) {
        return false; // Success, remove from queue
      }

      if (res.status >= 400 && res.status < 500) {
        // Client error, don't retry
        return false;
      }

      // Server error, retry
      item.attempts = (item.attempts || 0) + 1;
      return item.attempts < MAX_RETRY_ATTEMPTS;

    } catch(e) {
      item.attempts = (item.attempts || 0) + 1;
      return item.attempts < MAX_RETRY_ATTEMPTS;
    }
  }

  // Schedule batch processing
  function scheduleBatchProcessing() {
    clearTimeout(batchTimer);
    batchTimer = setTimeout(() => {
      if (navigator.onLine) {
        processQueues();
      }
    }, BATCH_DELAY_MS);
  }

  /* ================= Fast Scan Handlers ================= */
  function quickStudentIn({ legacyId, firstName, lastName, grade, src }) {
    const key = State.makeKey({ pin: legacyId, personId: '' });
    if (!State.canSendNow(key)) {
      Toast.show('Duplicate scan ignored (5s)', false);
      return;
    }

    const eventTs = Date.now();
    const label = `${firstName||''} ${lastName||''}`.trim() || 'Student';

    const kioskURL = VC_BASE + encodeURIComponent(legacyId);
    window.open(kioskURL, '_blank', 'width=480,height=820,noopener,noreferrer');
    Toast.show(`${label} ‚Äî sent to Veracross`, true);
    try { Chime.ok(); navigator.vibrate?.(30); } catch(_) {}

    State.queueScan({
      action: 'in',
      src: src || 'tap_student',
      pin: String(legacyId),
      personId: '',
      firstName: firstName||'',
      lastName: lastName||'',
      grade: grade||'',
      clientTs: String(eventTs)
    });

    updateQueueStatusLabel();
    scheduleBatchProcessing();
  }

  function quickStudentOut({ legacyId, firstName, lastName, grade, src }) {
    const key = State.makeKey({ pin: legacyId, personId: '' });
    if (!State.canSendNow(key)) {
      Toast.show('Duplicate scan ignored (5s)', false);
      return;
    }

    const eventTs = Date.now();
    const now = new Date(eventTs);
    const timeStr = now.toLocaleTimeString('en-US', { hour:'numeric', minute:'2-digit' });
    const who = `${firstName||''} ${lastName||''}`.trim() || 'Student';

    Toast.show(`${who} ‚Äî signed OUT ‚Äî ${timeStr}`, true);
    try { Chime.ok(); navigator.vibrate?.(30); } catch (_) {}

    State.queueScan({
      action: 'out',
      src: src || 'tap_student',
      pin: String(legacyId),
      personId: '',
      firstName: firstName||'',
      lastName: lastName||'',
      grade: grade||'',
      clientTs: String(eventTs)
    });

    updateQueueStatusLabel();
    scheduleBatchProcessing();
  }

  function quickFacultyAction({ personId, pin, firstName, lastName, src }) {
    const act = State.action;
    const key = State.makeKey({ pin, personId });
    if (!State.canSendNow(key)) {
      Toast.show('Duplicate scan ignored (5s)', false);
      return;
    }

    const eventTs = Date.now();
    const now = new Date(eventTs);
    const timeStr = now.toLocaleTimeString('en-US', { hour:'numeric', minute:'2-digit' });
    const who  = `${firstName||''} ${lastName||''}`.trim() || 'Faculty';
    const verb = act === 'in' ? 'IN' : 'OUT';

    Toast.show(`${who} signed ${verb} ‚Äî ${timeStr}`, true);
    try { Chime.ok(); navigator.vibrate?.(30); } catch(_) {}

    State.queueScan({
      action: act,
      src: src || (pin ? 'tap_faculty' : 'search_faculty'),
      pin: pin || '',
      personId: personId || '',
      firstName: firstName || '',
      lastName: lastName || '',
      grade: '',
      clientTs: String(eventTs)
    });

    updateQueueStatusLabel();
    scheduleBatchProcessing();
  }

  function quickUnknownCardFail(pin){
    const key = State.makeKey({ pin, personId: '' });
    if (!State.canSendNow(key)) {
      Toast.show('Duplicate scan ignored (5s)', false);
      return;
    }

    const eventTs = Date.now();
    Toast.show('Cougar Card not found', false);
    Chime.fail();
    try { navigator.vibrate?.(40); } catch(_){}

    State.queueError({
      action: 'client_error',
      note: 'card_not_found',
      a: State.action,
      pin: String(pin),
      src: 'tap_unknown'
    });

    State.queueScan({
      action: State.action,
      src: 'tap_unknown',
      pin: String(pin),
      personId: '',
      firstName: '',
      lastName: '',
      grade: '',
      clientTs: String(eventTs)
    });

    updateQueueStatusLabel();
    scheduleBatchProcessing();
  }

  /* ================= Card Input ================= */
  let wedgeTimer = null;
  pinEl.addEventListener('input', ()=>{
    clearTimeout(wedgeTimer);
    wedgeTimer = setTimeout(()=>{
      const d = digitsOnly(pinEl.value);
      if (d.length < 10) return;

      const ten = d.slice(-10);
      if (Date.now() - State.lastSubmit < COOLDOWN_MS) return;

      const isIn = State.action === 'in';
      const hasRoster = State.roster.students.size > 0 || State.roster.faculty.size > 0;

      if (hasRoster) {
        if (State.roster.students.has(ten)) {
          const rec = State.roster.students.get(ten);
          if (isIn) {
            quickStudentIn({
              legacyId: ten,
              firstName: rec.firstName || '',
              lastName: rec.lastName || '',
              grade: rec.grade || '',
              src: 'tap_student'
            });
          } else {
            quickStudentOut({
              legacyId: ten,
              firstName: rec.firstName || '',
              lastName: rec.lastName || '',
              grade: rec.grade || '',
              src: 'tap_student'
            });
          }
        } else if (State.roster.faculty.has(ten)) {
          const rec = State.roster.faculty.get(ten);
          quickFacultyAction({
            pin: ten,
            personId: rec.personId || '',
            firstName: rec.firstName || '',
            lastName: rec.lastName || '',
            src: 'tap_faculty'
          });
        } else {
          quickUnknownCardFail(ten);
        }
      } else {
        // Fallback: queue with unknown
        quickUnknownCardFail(ten);
      }

      pinEl.value = '';
      focusPinSafely();
      State.lastSubmit = Date.now();
    }, WEDGE_QUIET_MS);
  }, { passive:true });

  /* ================= Search ================= */
  let searchTimer = null;
  const searchCache = new Map();

  qEl.addEventListener('input', ()=>{
    clearTimeout(searchTimer);
    const q = qEl.value.trim();
    const box = $('#results');
    if (!q) {
      box.innerHTML = '';
      return;
    }
    searchTimer = setTimeout(()=>doSearch(q), 150);
  });

  qEl.addEventListener('keydown', (e)=>{
    if (e.key === 'Enter') {
      clearTimeout(searchTimer);
      const q = qEl.value.trim();
      if (!q) {
        $('#results').innerHTML = '';
        e.preventDefault();
        return;
      }
      doSearch(q);
      e.preventDefault();
    }
  });

  function clearSearchUI(){
    qEl.value = '';
    $('#results').innerHTML = '';
    focusPinSafely();
  }

  function sectionHeader(text){
    const div = document.createElement('div');
    div.className='sectionHdr';
    div.textContent = text;
    return div;
  }

  function resultRow(label, btnText, onClick){
    const row = document.createElement('div');
    row.className='row';
    const name = document.createElement('div');
    name.className='name';
    name.textContent = label;
    const btn = document.createElement('button');
    btn.className='actionBtn';
    btn.textContent = btnText;
    btn.addEventListener('click', ()=>{
      onClick();
      clearSearchUI();
    });
    row.appendChild(name);
    row.appendChild(btn);
    return row;
  }

  function norm(s){
    return String(s||'').toLowerCase().normalize('NFKD').replace(/[\u0300-\u036f]/g,'');
  }

  function scoreName(q, first, last, fullLF){
    const nq = norm(q);
    const nf = norm(first), nl = norm(last);
    const nfl = nf + ' ' + nl;
    const nlf = fullLF ? norm(fullLF) : (nl + ', ' + nf);
    
    if (nfl === nq || nlf === nq) return 1000;
    if (nf === nq || nl === nq) return 900;
    
    let s = 0;
    if (nf.startsWith(nq)) s += 120;
    if (nl.startsWith(nq)) s += 110;
    if (nfl.startsWith(nq)) s += 100;
    if (nlf.startsWith(nq)) s += 95;
    if (nf.includes(nq)) s += 30;
    if (nl.includes(nq)) s += 28;
    if (nfl.includes(nq)) s += 26;
    if (nlf.includes(nq)) s += 24;
    return s;
  }

  function flipLF(full){
    const m = String(full||'').match(/^\s*([^,]+)\s*,\s*(.+)\s*$/);
    return m ? {first:m[2].trim(), last:m[1].trim()} : {first:String(full||'').trim(), last:''};
  }

  function doSearch(q){
    const box = $('#results');
    const hasRoster = State.roster.studentList.length > 0 || State.roster.facultyList.length > 0;

    if (hasRoster) {
      box.innerHTML = '<div class="muted" style="text-align:center;">Searching‚Ä¶</div>';
      localSearch(q);
    } else {
      box.innerHTML = '<div class="muted" style="text-align:center;">Roster not loaded</div>';
    }
  }

  function localSearch(q){
    const nq = q.trim();
    if (!nq){
      $('#results').innerHTML = '';
      return;
    }

    const fac = [];
    for (const r of State.roster.facultyList){
      const { firstName, lastName, personId } = r;
      const score = scoreName(nq, firstName||'', lastName||'');
      if (score <= 0) continue;
      fac.push({ firstName, lastName, personId, _score:score });
    }

    const stu = [];
    for (const r of State.roster.studentList){
      const fullName = r.fullName || `${r.lastName||''}, ${r.firstName||''}`;
      const flip = flipLF(fullName);
      const score = scoreName(nq, flip.first||'', flip.last||'', fullName);
      if (score <= 0) continue;
      stu.push({
        fullName,
        legacyId: r.legacyId,
        grade: r.grade,
        _flip: flip,
        _score: score
      });
    }

    const facSorted = fac.sort((a,b)=>b._score - a._score).slice(0,30);
    const stuSorted = stu.sort((a,b)=>b._score - a._score).slice(0,30);

    renderSearch(facSorted, stuSorted);
  }

  function renderSearch(facSorted, stuSorted){
    const frag = document.createDocumentFragment();

    if (facSorted.length) {
      frag.appendChild(sectionHeader('FACULTY'));
      facSorted.forEach(({ firstName, lastName, personId })=>{
        const label = `${firstName} ${lastName}`.trim() || 'Faculty';
        frag.appendChild(resultRow(
          label,
          'Submit',
          ()=> quickFacultyAction({
            personId,
            pin: '',
            firstName,
            lastName,
            src: 'search_faculty'
          })
        ));
      });
    }

    if (stuSorted.length) {
      frag.appendChild(sectionHeader('STUDENTS'));
      stuSorted.forEach(({ fullName, legacyId, _flip, grade })=>{
        const firstName = _flip.first || '';
        const lastName  = _flip.last  || '';
        const label = (firstName ? `${firstName} ${lastName}` : fullName).trim() || 'Student';
        frag.appendChild(resultRow(
          label,
          'Submit',
          ()=> {
            const isOut = State.action === 'out';
            if (isOut) {
              quickStudentOut({
                legacyId: String(legacyId),
                firstName,
                lastName,
                grade,
                src: 'search_student'
              });
            } else {
              quickStudentIn({
                legacyId: String(legacyId),
                firstName,
                lastName,
                grade,
                src: 'search_student'
              });
            }
          }
        ));
      });
    }

    const box = $('#results');
    box.replaceChildren();
    if (!facSorted.length && !stuSorted.length) {
      box.innerHTML = '<div class="muted" style="text-align:center;">No matches found.</div>';
    } else {
      box.appendChild(frag);
    }
  }

  /* ================= Overlay helpers ================= */
  function showBootOverlay(text){
    if (!bootOverlay) return;
    const t = bootOverlay.querySelector('.boot-text');
    if (t && text) t.textContent = text;
    bootOverlay.style.display = 'flex';
  }

  function hideBootOverlay(){
    if (!bootOverlay) return;
    bootOverlay.style.display = 'none';
  }

  /* ================= Init ================= */
  document.addEventListener('DOMContentLoaded', async ()=>{
    initTheme();
    updateNet();
    State.load();

    updateRosterStatusLabel();
    updateQueueStatusLabel();

    pinEl.disabled = true;
    qEl.disabled   = true;
    showBootOverlay('Loading rosters‚Ä¶');

    try{
      await loadBootstrap();
      hideBootOverlay();
      Toast.show('Kiosk ready (fast mode)', true, 1400);
    }catch(e){
      hideBootOverlay();
      Toast.show('Using cached roster ‚Äî will retry sync in background', false, 2600);
    }

    pinEl.disabled = false;
    qEl.disabled   = false;

    setAction(State.action);
    applyHashAction();

    setTimeout(()=>{ pinEl.focus(); }, 0);

    // Process any pending queues
    if (navigator.onLine) {
      setTimeout(processQueues, 1000);
    }

    // Periodic queue processing
    setInterval(() => {
      if (navigator.onLine && !State.queue.syncing) {
        processQueues();
      }
    }, 60000); // Every minute
  });
})();
</script>
</body>
</html>
